"""
Esta p√°gina proporciona an√°lisis comparativo entre sectores econ√≥micos,
tendencias temporales y benchmarking de riesgo por industria.
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

from utils.api_client import api_client, handle_api_errors
from config.settings import RISK_COLORS, RISK_ICONS
from components.sidebar import show_page_header
from components.auth import has_permission, show_permission_error

@handle_api_errors
def get_sectorial_data():
    """Obtiene datos para an√°lisis sectorial"""
    
    # Obtener datos de m√∫ltiples endpoints
    riesgo_sectorial = api_client.get_riesgo_sectorial()
    tendencias = api_client.get_tendencias_temporales(periodo='trimestre', limite=8)
    overview = api_client.get_dashboard_overview()
    
    return {
        'riesgo_sectorial': riesgo_sectorial.data if riesgo_sectorial.success else None,
        'tendencias': tendencias.data if tendencias.success else None,
        'overview': overview.data if overview.success else None
    }

def show_sectorial_overview(data: Dict[str, Any]):
    """Muestra overview del an√°lisis sectorial"""
    
    riesgo_data = data.get('riesgo_sectorial', {})
    sectores = riesgo_data.get('sectores', [])
    
    if not sectores:
        st.error("No hay datos sectoriales disponibles")
        return
    
    st.markdown("### üìä Resumen Sectorial")
    
    # M√©tricas generales
    total_sectores = len(sectores)
    total_empresas = sum(s.get('total_empresas', 0) for s in sectores)
    sector_mas_riesgo = max(sectores, key=lambda x: x.get('porcentaje_riesgo_alto', 0))
    sector_menos_riesgo = min(sectores, key=lambda x: x.get('porcentaje_riesgo_alto', 0))
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Sectores Analizados",
            total_sectores,
            delta=None
        )
    
    with col2:
        st.metric(
            "Total Empresas",
            f"{total_empresas:,}",
            delta=None
        )
    
    with col3:
        st.metric(
            "Mayor Riesgo",
            sector_mas_riesgo.get('sector', 'N/A'),
            delta=f"{sector_mas_riesgo.get('porcentaje_riesgo_alto', 0):.1f}%",
            delta_color="inverse"
        )
    
    with col4:
        st.metric(
            "Menor Riesgo",
            sector_menos_riesgo.get('sector', 'N/A'),
            delta=f"{sector_menos_riesgo.get('porcentaje_riesgo_alto', 0):.1f}%",
            delta_color="normal"
        )

def show_risk_by_sector_chart(sectores: List[Dict[str, Any]]):
    """Muestra gr√°fico de riesgo por sector"""
    
    if not sectores:
        st.warning("No hay datos de sectores disponibles")
        return
    
    st.markdown("### üè≠ Distribuci√≥n de Riesgo por Sector")
    
    # Preparar datos
    df_sectores = pd.DataFrame(sectores)
    
    # Ordenar por porcentaje de riesgo alto
    df_sectores = df_sectores.sort_values('porcentaje_riesgo_alto', ascending=True)
    
    # Crear gr√°fico de barras horizontales
    fig = go.Figure()
    
    # A√±adir barras para cada nivel de riesgo
    risk_levels = ['riesgo_bajo', 'riesgo_medio', 'riesgo_alto', 'riesgo_critico']
    risk_colors = ['#2ca02c', '#ffbb78', '#ff7f0e', '#d62728']
    risk_names = ['Bajo', 'Medio', 'Alto', 'Cr√≠tico']
    
    for i, (level, color, name) in enumerate(zip(risk_levels, risk_colors, risk_names)):
        if level in df_sectores.columns:
            fig.add_trace(go.Bar(
                name=f'Riesgo {name}',
                y=df_sectores['sector'],
                x=df_sectores[level],
                orientation='h',
                marker_color=color,
                hovertemplate=f'<b>%{{y}}</b><br>Riesgo {name}: %{{x}}<br><extra></extra>'
            ))
    
    fig.update_layout(
        title="Distribuci√≥n de Empresas por Nivel de Riesgo y Sector",
        xaxis_title="N√∫mero de Empresas",
        yaxis_title="Sector",
        barmode='stack',
        height=max(400, len(sectores) * 40),
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    
    st.plotly_chart(fig, use_container_width=True)

def show_sector_comparison_table(sectores: List[Dict[str, Any]]):
    """Muestra tabla comparativa de sectores"""
    
    if not sectores:
        return
    
    st.markdown("### üìã Comparativa Detallada por Sector")
    
    # Preparar datos para la tabla
    tabla_sectores = []
    for sector in sectores:
        tabla_sectores.append({
            'Sector': sector['sector'],
            'Total Empresas': sector['total_empresas'],
            '% Riesgo Alto': f"{sector.get('porcentaje_riesgo_alto', 0):.1f}%",
            'Prob. ML Promedio': f"{sector.get('probabilidad_promedio', 0):.3f}",
            'Altman Promedio': f"{sector.get('altman_promedio', 0):.2f}",
            'Empresas Riesgo Alto': sector.get('riesgo_alto', 0),
            'Ranking Riesgo': 0  # Se calcular√° despu√©s
        })
    
    df_tabla = pd.DataFrame(tabla_sectores)
    
    # Calcular ranking de riesgo
    df_tabla['Ranking Riesgo'] = df_tabla['% Riesgo Alto'].str.rstrip('%').astype(float).rank(ascending=False, method='min').astype(int)
    
    # Ordenar por ranking
    df_tabla = df_tabla.sort_values('Ranking Riesgo')
    
    # Mostrar tabla con configuraci√≥n especial
    st.dataframe(
        df_tabla,
        use_container_width=True,
        hide_index=True,
        column_config={
            "% Riesgo Alto": st.column_config.ProgressColumn(
                "% Riesgo Alto",
                help="Porcentaje de empresas en riesgo alto",
                min_value=0,
                max_value=100,
                format="%.1f%%"
            ),
            "Prob. ML Promedio": st.column_config.ProgressColumn(
                "Probabilidad ML Promedio",
                help="Probabilidad promedio de quiebra seg√∫n ML",
                min_value=0,
                max_value=1,
                format="%.3f"
            ),
            "Ranking Riesgo": st.column_config.NumberColumn(
                "Ranking",
                help="Posici√≥n en ranking de riesgo (1 = mayor riesgo)",
                format="%d"
            )
        }
    )

def show_sector_heatmap(sectores: List[Dict[str, Any]]):
    """Muestra heatmap de m√©tricas por sector"""
    
    if not sectores:
        return
    
    st.markdown("### üî• Mapa de Calor - M√©tricas por Sector")
    
    # Preparar datos para heatmap
    df_sectores = pd.DataFrame(sectores)
    
    # Seleccionar m√©tricas num√©ricas
    metricas = ['total_empresas', 'porcentaje_riesgo_alto', 'probabilidad_promedio', 'altman_promedio']
    metricas_nombres = ['Total Empresas', '% Riesgo Alto', 'Prob. ML Promedio', 'Altman Promedio']
    
    # Crear matriz para heatmap
    matriz_datos = []
    for metrica in metricas:
        if metrica in df_sectores.columns:
            matriz_datos.append(df_sectores[metrica].values)
    
    if not matriz_datos:
        st.warning("No hay datos suficientes para el heatmap")
        return
    
    # Normalizar datos para mejor visualizaci√≥n
    matriz_normalizada = []
    for fila in matriz_datos:
        if fila.max() > 0:
            fila_norm = (fila - fila.min()) / (fila.max() - fila.min())
        else:
            fila_norm = fila
        matriz_normalizada.append(fila_norm)
    
    # Crear heatmap
    fig = go.Figure(data=go.Heatmap(
        z=matriz_normalizada,
        x=df_sectores['sector'].values,
        y=metricas_nombres,
        colorscale='RdYlBu_r',
        hoverongaps=False,
        hovertemplate='<b>%{y}</b><br>Sector: %{x}<br>Valor normalizado: %{z:.2f}<extra></extra>'
    ))
    
    fig.update_layout(
        title="Mapa de Calor - M√©tricas Normalizadas por Sector",
        xaxis_title="Sector",
        yaxis_title="M√©trica",
        height=400
    )
    
    st.plotly_chart(fig, use_container_width=True)

def show_temporal_trends_by_sector(tendencias_data: Dict[str, Any]):
    """Muestra tendencias temporales por sector"""
    
    if not tendencias_data:
        st.warning("No hay datos de tendencias disponibles")
        return
    
    st.markdown("### üìà Evoluci√≥n Temporal por Sector")
    
    # Simular datos de tendencias por sector (en una implementaci√≥n real vendr√≠a de la API)
    # Por ahora mostraremos tendencias generales
    tendencias = tendencias_data.get('tendencias', [])
    
    if not tendencias:
        st.info("No hay datos de tendencias temporales disponibles")
        return
    
    # Preparar datos
    df_tendencias = pd.DataFrame(tendencias)
    df_tendencias['periodo'] = pd.to_datetime(df_tendencias['periodo'])
    
    # Crear gr√°fico de l√≠neas
    fig = go.Figure()
    
    # L√≠nea de porcentaje de riesgo alto
    fig.add_trace(go.Scatter(
        x=df_tendencias['periodo'],
        y=df_tendencias['porcentaje_riesgo_alto'],
        mode='lines+markers',
        name='% Riesgo Alto General',
        line=dict(color='#d62728', width=3),
        marker=dict(size=8)
    ))
    
    # L√≠nea de total de predicciones (escala secundaria)
    fig.add_trace(go.Scatter(
        x=df_tendencias['periodo'],
        y=df_tendencias['total_predicciones'],
        mode='lines+markers',
        name='Total Predicciones',
        line=dict(color='#1f77b4', width=3),
        marker=dict(size=8),
        yaxis='y2'
    ))
    
    fig.update_layout(
        title="Evoluci√≥n Temporal del Riesgo Empresarial",
        xaxis_title="Per√≠odo",
        yaxis_title="Porcentaje de Riesgo Alto (%)",
        yaxis2=dict(
            title="Total Predicciones",
            overlaying='y',
            side='right'
        ),
        height=400,
        showlegend=True
    )
    
    st.plotly_chart(fig, use_container_width=True)

def show_sector_benchmarking():
    """Muestra benchmarking sectorial"""
    
    st.markdown("### üéØ Benchmarking Sectorial")
    
    # Selector de sector para benchmarking
    col1, col2 = st.columns([2, 1])
    
    with col1:
        sector_seleccionado = st.selectbox(
            "Seleccionar Sector para Benchmarking",
            ["Technology", "Manufacturing", "Services", "Finance", "Healthcare", "Retail"],
            index=0
        )
    
    with col2:
        if st.button("üîÑ Actualizar An√°lisis"):
            st.rerun()
    
    # Cargar datos espec√≠ficos del sector
    with st.spinner(f"Analizando sector {sector_seleccionado}..."):
        # En una implementaci√≥n real, esto vendr√≠a de una API espec√≠fica
        show_sector_specific_analysis(sector_seleccionado)

def show_sector_specific_analysis(sector: str):
    """Muestra an√°lisis espec√≠fico de un sector"""
    
    # Simular datos espec√≠ficos del sector
    # En implementaci√≥n real vendr√≠a de API
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown(f"#### üìä M√©tricas de {sector}")
        
        # M√©tricas simuladas
        st.metric("Empresas en el Sector", "1,234", delta="12 vs mes anterior")
        st.metric("% Riesgo Alto", "15.3%", delta="-2.1% vs promedio general", delta_color="normal")
        st.metric("Prob. ML Promedio", "0.087", delta="-0.023 vs promedio general", delta_color="normal")
        st.metric("Altman Promedio", "2.45", delta="+0.34 vs promedio general", delta_color="normal")
    
    with col2:
        st.markdown(f"#### üèÜ Ranking vs Otros Sectores")
        
        # Ranking simulado
        ranking_data = {
            'M√©trica': ['Menor Riesgo', 'Mayor Estabilidad', 'Mejor Altman', 'M√°s Empresas'],
            'Posici√≥n': ['3/6', '2/6', '4/6', '1/6'],
            'Percentil': ['50%', '83%', '33%', '100%']
        }
        
        df_ranking = pd.DataFrame(ranking_data)
        st.dataframe(df_ranking, use_container_width=True, hide_index=True)
    
    # Distribuci√≥n de empresas en el sector
    st.markdown(f"#### üìà Distribuci√≥n de Riesgo en {sector}")
    
    # Datos simulados de distribuci√≥n
    distribucion_simulada = {
        'Banda de Riesgo': ['Bajo', 'Medio', 'Alto', 'Cr√≠tico'],
        'Cantidad': [450, 320, 180, 50],
        'Porcentaje': [45.0, 32.0, 18.0, 5.0]
    }
    
    df_dist = pd.DataFrame(distribucion_simulada)
    
    # Gr√°fico de barras
    fig = px.bar(
        df_dist,
        x='Banda de Riesgo',
        y='Cantidad',
        title=f"Distribuci√≥n de Empresas por Riesgo - {sector}",
        color='Banda de Riesgo',
        color_discrete_map={
            'Bajo': '#2ca02c',
            'Medio': '#ffbb78',
            'Alto': '#ff7f0e',
            'Cr√≠tico': '#d62728'
        }
    )
    
    fig.update_layout(height=400, showlegend=False)
    st.plotly_chart(fig, use_container_width=True)

def show_sector_recommendations(sector: str):
    """Muestra recomendaciones espec√≠ficas del sector"""
    
    st.markdown(f"#### üí° Recomendaciones para {sector}")
    
    # Recomendaciones simuladas basadas en el sector
    recomendaciones = {
        'Technology': [
            "üîç Monitorear empresas con alta dependencia de financiamiento externo",
            "üìä Evaluar impacto de cambios en tasas de inter√©s",
            "üöÄ Considerar volatilidad del mercado tech en evaluaciones",
            "üí∞ Revisar m√©tricas de burn rate y runway financiero"
        ],
        'Manufacturing': [
            "üè≠ Monitorear costos de materias primas y energ√≠a",
            "üì¶ Evaluar cadenas de suministro y dependencias",
            "üåç Considerar impacto de regulaciones ambientales",
            "‚öôÔ∏è Revisar niveles de automatizaci√≥n y eficiencia"
        ],
        'Services': [
            "üë• Evaluar dependencia de recursos humanos especializados",
            "üìç Considerar impacto de ubicaci√≥n geogr√°fica",
            "üíº Monitorear contratos a largo plazo y recurrencia",
            "üîÑ Revisar capacidad de adaptaci√≥n a cambios del mercado"
        ],
        'Finance': [
            "üè¶ Monitorear exposici√≥n a riesgo crediticio",
            "üìà Evaluar impacto de cambios regulatorios",
            "üí± Considerar volatilidad de mercados financieros",
            "üîí Revisar adecuaci√≥n de capital y liquidez"
        ],
        'Healthcare': [
            "üè• Evaluar dependencia de reembolsos gubernamentales",
            "üíä Monitorear cambios en regulaciones sanitarias",
            "üë®‚Äç‚öïÔ∏è Considerar escasez de personal especializado",
            "üî¨ Revisar inversiones en tecnolog√≠a m√©dica"
        ],
        'Retail': [
            "üõí Monitorear cambios en patrones de consumo",
            "üåê Evaluar competencia del comercio electr√≥nico",
            "üì¶ Considerar costos de inventario y log√≠stica",
            "üè™ Revisar ubicaci√≥n y costos de locales f√≠sicos"
        ]
    }
    
    sector_recs = recomendaciones.get(sector, [
        "üìä Realizar an√°lisis espec√≠fico del sector",
        "üîç Monitorear indicadores clave de la industria",
        "üìà Evaluar tendencias del mercado",
        "üí° Considerar factores espec√≠ficos del negocio"
    ])
    
    for rec in sector_recs:
        st.markdown(f"- {rec}")

def show_export_options():
    """Muestra opciones de exportaci√≥n de an√°lisis"""
    
    st.markdown("### üì• Exportar An√°lisis")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üìä Exportar a Excel", use_container_width=True):
            st.info("Funcionalidad de exportaci√≥n en desarrollo")
    
    with col2:
        if st.button("üìÑ Generar Reporte PDF", use_container_width=True):
            st.info("Funcionalidad de reporte en desarrollo")
    
    with col3:
        if st.button("üìß Enviar por Email", use_container_width=True):
            st.info("Funcionalidad de email en desarrollo")

def show_page():
    """Funci√≥n principal de la p√°gina de an√°lisis sectorial"""
    
    # Header de la p√°gina
    show_page_header(
        "An√°lisis Sectorial",
        "Comparativas y tendencias por sector econ√≥mico",
        "üìà"
    )
    
    # Verificar permisos
    if not has_permission('predicciones', 'read'):
        show_permission_error('predicciones', 'read')
        return
    
    # Cargar datos
    with st.spinner("Cargando datos sectoriales..."):
        data = get_sectorial_data()
    
    if not data or not data.get('riesgo_sectorial'):
        st.error("No se pudieron cargar los datos sectoriales")
        return
    
    # Overview sectorial
    show_sectorial_overview(data)
    
    st.markdown("---")
    
    # Tabs principales
    tab1, tab2, tab3, tab4 = st.tabs(["üìä Comparativa", "üìà Tendencias", "üéØ Benchmarking", "üì• Exportar"])
    
    with tab1:
        sectores = data['riesgo_sectorial'].get('sectores', [])
        
        # Gr√°fico de riesgo por sector
        show_risk_by_sector_chart(sectores)
        
        st.markdown("---")
        
        # Tabla comparativa
        show_sector_comparison_table(sectores)
        
        st.markdown("---")
        
        # Heatmap
        show_sector_heatmap(sectores)
    
    with tab2:
        # Tendencias temporales
        show_temporal_trends_by_sector(data.get('tendencias'))
        
        st.markdown("---")
        
        # An√°lisis de estacionalidad
        st.markdown("### üìÖ An√°lisis de Estacionalidad")
        st.info("Funcionalidad de an√°lisis de estacionalidad en desarrollo")
        
        # Placeholder para an√°lisis futuro
        st.markdown("""
        **Pr√≥ximas funcionalidades:**
        - An√°lisis de estacionalidad por sector
        - Correlaciones con indicadores macroecon√≥micos
        - Predicci√≥n de tendencias futuras
        - Alertas de cambios significativos
        """)
    
    with tab3:
        # Benchmarking sectorial
        show_sector_benchmarking()
        
        # Selector de sector
        sector_seleccionado = st.session_state.get('sector_benchmark', 'Technology')
        
        st.markdown("---")
        
        # Recomendaciones
        show_sector_recommendations(sector_seleccionado)
    
    with tab4:
        # Opciones de exportaci√≥n
        show_export_options()
        
        st.markdown("---")
        
        # Configuraci√≥n de reportes
        st.markdown("### ‚öôÔ∏è Configuraci√≥n de Reportes")
        
        col1, col2 = st.columns(2)
        
        with col1:
            incluir_graficos = st.checkbox("Incluir gr√°ficos", value=True)
            incluir_tablas = st.checkbox("Incluir tablas detalladas", value=True)
        
        with col2:
            formato_fecha = st.selectbox("Formato de fecha", ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"])
            idioma_reporte = st.selectbox("Idioma", ["Espa√±ol", "Ingl√©s"])
        
        st.markdown("---")
        
        # Programar reportes
        st.markdown("### üìÖ Programar Reportes Autom√°ticos")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            frecuencia = st.selectbox("Frecuencia", ["Semanal", "Mensual", "Trimestral"])
        
        with col2:
            dia_envio = st.selectbox("D√≠a de env√≠o", ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes"])
        
        with col3:
            email_destino = st.text_input("Email destino", placeholder="usuario@empresa.com")
        
        if st.button("üìß Programar Reporte Autom√°tico"):
            st.success("Reporte programado exitosamente (funcionalidad en desarrollo)")

if __name__ == "__main__":
    show_page()

